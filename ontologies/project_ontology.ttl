PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ex: <http://example.org/ontology/>
PREFIX em: <http://example.org/emoji#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

owl:imports <http://example.org/agent_ontology.ttl> .

<http://example.org/ontology/closestEmoji/0>
  ex:emojiCategory "Lean4",
    "Visualization",
    "Workflow";
  ex:emojiChar "üëÄüìÇ",
    "üìäüé®",
    "üìêüåê",
    "üß†üîç";
  ex:emojiDistance "0.04312365502119064"^^xsd:double,
    "0.05444573611021042"^^xsd:double,
    "0.054579298943281174"^^xsd:double,
    "0.05499028041958809"^^xsd:double,
    "0.057122644037008286"^^xsd:double,
    "0.05747762694954872"^^xsd:double,
    "0.05905671417713165"^^xsd:double,
    "0.059091463685035706"^^xsd:double,
    "0.06373164802789688"^^xsd:double,
    "0.06718189269304276"^^xsd:double,
    "0.06819441169500351"^^xsd:double,
    "0.06891225278377533"^^xsd:double,
    "0.07415061444044113"^^xsd:double,
    "0.07597557455301285"^^xsd:double,
    "0.082443006336689"^^xsd:double,
    "0.09920278191566467"^^xsd:double,
    "0.12495599687099457"^^xsd:double.

<http://example.org/ontology/closestEmoji/1>
  ex:emojiCategory "GitHub",
    "Lean4",
    "Visualization",
    "Workflow";
  ex:emojiChar "üëÄüìÇ",
    "üìäüé®",
    "üì¶üêô",
    "üì¶üîß",
    "üîóüåê",
    "üß†üîç",
    "üß©üìê";
  ex:emojiDistance "0.0598081611096859"^^xsd:double,
    "0.06762274354696274"^^xsd:double,
    "0.07769563049077988"^^xsd:double,
    "0.07776068896055222"^^xsd:double,
    "0.07779701054096222"^^xsd:double,
    "0.07824254781007767"^^xsd:double,
    "0.07872689515352249"^^xsd:double,
    "0.07955489307641983"^^xsd:double,
    "0.08155252039432526"^^xsd:double,
    "0.08278314024209976"^^xsd:double,
    "0.0852993056178093"^^xsd:double,
    "0.0866101086139679"^^xsd:double,
    "0.0866304486989975"^^xsd:double,
    "0.0877903550863266"^^xsd:double,
    "0.09453178942203522"^^xsd:double,
    "0.10580005496740341"^^xsd:double,
    "0.1377744823694229"^^xsd:double.

<http://example.org/ontology/closestEmoji/2>
  ex:emojiCategory "GitHub",
    "Reporting",
    "Visualization",
    "Workflow";
  ex:emojiChar "üëÄüìÇ",
    "üìÑ‚û°Ô∏è",
    "üìäüé®",
    "üìäüß±",
    "üì¶üêô",
    "üîóüåê";
  ex:emojiDistance "0.06546766310930252"^^xsd:double,
    "0.0693826675415039"^^xsd:double,
    "0.07784070819616318"^^xsd:double,
    "0.07911279797554016"^^xsd:double,
    "0.08000651746988297"^^xsd:double,
    "0.08046574145555496"^^xsd:double,
    "0.08048766851425171"^^xsd:double,
    "0.08167190849781036"^^xsd:double,
    "0.08250442147254944"^^xsd:double,
    "0.08385110646486282"^^xsd:double,
    "0.08666647970676422"^^xsd:double,
    "0.08735791593790054"^^xsd:double,
    "0.08955057710409164"^^xsd:double,
    "0.09067212790250778"^^xsd:double,
    "0.09462316334247589"^^xsd:double,
    "0.10960085690021515"^^xsd:double,
    "0.1390817016363144"^^xsd:double.

<http://example.org/ontology/file/__src_embedding_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/embedding.rs".

<http://example.org/ontology/file/__src_function_analyzer_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/function_analyzer.rs".

<http://example.org/ontology/file/__src_load_emoji_multivectors_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/load_emoji_multivectors.rs".

<http://example.org/ontology/file/__src_main_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/main.rs".

<http://example.org/ontology/file/__src_ontology_generator_mod_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/ontology_generator/mod.rs".

<http://example.org/ontology/file/__src_ontology_generator_namespaces_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/ontology_generator/namespaces.rs".

<http://example.org/ontology/file/__src_ontology_generator_process_function_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/ontology_generator/process_function.rs".

<http://example.org/ontology/file/__src_ontology_generator_serialize_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/ontology_generator/serialize.rs".

<http://example.org/ontology/file/__src_process_file_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/process_file.rs".

<http://example.org/ontology/file/__src_project_analyzer_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/project_analyzer.rs".

<http://example.org/ontology/file/__src_sieve_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/sieve.rs".

<http://example.org/ontology/file/__src_tests_rs>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:CodeFile;
  rdfs:label "./src/tests.rs".

<http://example.org/ontology/function/analyze_project>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn analyze_project (project_root : & Path , ontology_path : & Path) -> Result < Vec < AnalyzedFunction > > { let mut analyzed_functions = Vec :: new () ; let emoji_multivectors = load_emoji_multivectors (ontology_path . to_str () . unwrap ()) ? ; let bert_encoder = BertCliffordEncoder :: new (BertConfig :: default ()) ; let rust_files = crate :: function_analyzer :: find_rust_files (project_root) ; for file_path_str in rust_files { let file_path = Path :: new (& file_path_str) ; let functions_info_in_file = analyze_rust_file (file_path) ; for func_info in functions_info_in_file { let embedding = embed_text (& func_info . semantic_summary) ? ; let multivector = bert_encoder . encode_embedding (& embedding) ? ; let sieve_address = get_sieve_address (& multivector) ; let closest_emojis = find_closest_emojis (& multivector , & emoji_multivectors) ; analyzed_functions . push (AnalyzedFunction { function_name : func_info . function_name , code_snippet : func_info . code_snippet , semantic_summary : func_info . semantic_summary , file_path : func_info . file_path , multivector_str : format ! (\"{:?}\" , multivector) , sieve_address , closest_emojis , }) ; } } Ok (analyzed_functions) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.019705037, 0.0038651691, 0.0, 0.0007091989, 0.0, 0.0, 0.0, 0.019159038, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.011805711, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.03590252, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.022099944, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05711987, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "analyze_projectFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(project_root), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(ontology_path), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(AnalyzedFunction), arguments: PathArguments::None }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "11111011";
  ex:isInFile <http://example.org/ontology/file/__src_project_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "analyze_project".

<http://example.org/ontology/function/analyze_rust_file>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn analyze_rust_file (file_path : & Path) -> Vec < FunctionInfo > { let mut functions_info = Vec :: new () ; let code = std :: fs :: read_to_string (file_path) . expect (\"Failed to read file\") ; let syntax = syn :: parse_file (& code) . expect (\"Failed to parse file\") ; for item in syntax . items { if let syn :: Item :: Fn (item_fn) = item { let function_name = item_fn . sig . ident . to_string () ; let code_snippet = quote :: quote ! { # item_fn } . to_string () ; let semantic_summary = extract_semantic_summary (& item_fn) ; functions_info . push (FunctionInfo { function_name , code_snippet , semantic_summary , file_path : file_path . to_string_lossy () . replace (\"\\\\\" , \"/\") . to_owned () , multivector_str : String :: new () , sieve_address : String :: new () , closest_emoji : String :: new () , emoji_category : String :: new () , emoji_distance : 0.0 , }) ; } } functions_info }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.013529837, -0.014652228, 0.0, -0.008078078, 0.0, 0.0, 0.0, -0.002545746, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0055213873, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.022192778, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01270326, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.049743723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "analyze_rust_fileFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(file_path), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(FunctionInfo), arguments: PathArguments::None }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10001011";
  ex:isInFile <http://example.org/ontology/file/__src_function_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "analyze_rust_file".

<http://example.org/ontology/function/calculate_distance>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "fn calculate_distance (mv1 : & SolMultivector , mv2 : & SolMultivector) -> f32 { let mut sum_sq_diff = 0.0 ; for i in 0 .. SolCl :: dim () { sum_sq_diff += (mv1 . get_by_idx (i) - mv2 . get_by_idx (i)) . powi (2) ; } sum_sq_diff . sqrt () }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.014518972, -0.00016081193, 0.0, -0.010333213, 0.0, 0.0, 0.0, 0.011000012, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.010184394, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.027815621, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.013822176, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0242035, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "calculate_distanceFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(mv1), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(mv2), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(f32), arguments: PathArguments::None }] } }";
  ex:hasSieveAddress "10010011";
  ex:isInFile <http://example.org/ontology/file/__src_project_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "calculate_distance".

<http://example.org/ontology/function/define_namespaces>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn define_namespaces < 'a > () -> Namespaces < 'a > { let ex_iri : IriRef < String > = IriRef :: new_unchecked (\"http://example.org/ontology/\" . into ()) ; let rdf_iri : IriRef < String > = IriRef :: new_unchecked (\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" . into ()) ; let rdfs_iri : IriRef < String > = IriRef :: new_unchecked (\"http://www.w3.org/2000/01/rdf-schema#\" . into ()) ; let em_iri : IriRef < String > = IriRef :: new_unchecked (\"http://example.org/emoji#\" . into ()) ; let ex = ex_iri . clone () . into_term () ; let rdf = rdf_iri . clone () . into_term () ; let rdfs = rdfs_iri . clone () . into_term () ; let em = em_iri . clone () . into_term () ; Namespaces { ex_iri , rdf_iri , rdfs_iri , em_iri , ex , rdf , rdfs , em , } }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.0078493655, -0.010481557, 0.0, -0.010305908, 0.0, 0.0, 0.0, 0.010694058, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.004987235, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.018785667, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01554048, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05900339, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "define_namespacesType::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Namespaces), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Lifetime(Lifetime { apostrophe: Span, ident: Ident(a) })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10010011";
  ex:isInFile <http://example.org/ontology/file/__src_ontology_generator_namespaces_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "define_namespaces".

<http://example.org/ontology/function/embed_text>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn embed_text (text : & str) -> Result < Vec < f32 > > { let api = Api :: new () ? ; let model_id = \"sentence-transformers/all-MiniLM-L6-v2\" . to_string () ; let revision = \"main\" . to_string () ; let repo = api . repo (Repo :: with_revision (model_id , RepoType :: Model , revision)) ; let config_filename = repo . get (\"config.json\") ? ; let tokenizer_filename = repo . get (\"tokenizer.json\") ? ; let weights_filename = repo . get (\"model.safetensors\") ? ; let device = Device :: Cpu ; let config = std :: fs :: read_to_string (config_filename) ? ; let config : BertConfig = serde_json :: from_str (& config) ? ; let vb = unsafe { VarBuilder :: from_mmaped_safetensors (& [weights_filename] , DType :: F32 , & device) ? } ; let model = BertModel :: load (vb , & config) ? ; let tokenizer = Tokenizer :: from_file (tokenizer_filename) . map_err (| e | anyhow :: anyhow ! (e . to_string ())) ? ; let encoding = tokenizer . encode (text , true) . map_err (| e | anyhow :: anyhow ! (e . to_string ())) ? ; let token_ids = encoding . get_ids () . to_vec () ; let attention_mask = encoding . get_attention_mask () . to_vec () ; let max_len = config . max_position_embeddings ; let token_ids = if token_ids . len () > max_len { token_ids [.. max_len] . to_vec () } else { token_ids } ; let attention_mask = if attention_mask . len () > max_len { attention_mask [.. max_len] . to_vec () } else { attention_mask } ; let input_ids = Tensor :: new (token_ids . as_slice () , & device) ? . unsqueeze (0) ? ; let token_type_ids = input_ids . zeros_like () ? ; let attention_mask = Tensor :: new (attention_mask . as_slice () , & device) ? . unsqueeze (0) ? ; let embeddings = model . forward (& input_ids , & token_type_ids , Some (& attention_mask)) ? ; let (_n_sentence , n_tokens , _hidden_size) = embeddings . dims3 () ? ; let embeddings = (embeddings . sum_keepdim (1) ? / (n_tokens as f64)) ? ; let embeddings = embeddings . squeeze (0) ? . flatten_all () ? ; Ok (embeddings . to_vec1 () ?) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.020258175, -0.021617271, 0.0, -0.002645733, 0.0, 0.0, 0.0, 0.008341468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0055250446, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.014918753, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0043011955, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05757387, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "embed_textFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(text), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(str), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(f32), arguments: PathArguments::None }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10011001";
  ex:isInFile <http://example.org/ontology/file/__src_embedding_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "embed_text".

<http://example.org/ontology/function/extract_semantic_summary>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "fn extract_semantic_summary (item_fn : & syn :: ItemFn) -> String { let mut summary = String :: new () ; summary . push_str (& item_fn . sig . ident . to_string ()) ; for input in & item_fn . sig . inputs { summary . push_str (& format ! (\"{:?}\" , input)) ; } if let ReturnType :: Type (_ , ty) = & item_fn . sig . output { summary . push_str (& format ! (\"{:?}\" , ty)) ; } summary }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.010687388, 0.011080377, 0.0, -0.010755715, 0.0, 0.0, 0.0, -0.015406878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.010560647, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.020280283, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.024853647, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028276144, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "extract_semantic_summaryFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(item_fn), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(syn), arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident(ItemFn), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }";
  ex:hasSieveAddress "11001011";
  ex:isInFile <http://example.org/ontology/file/__src_function_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "extract_semantic_summary".

<http://example.org/ontology/function/find_closest_emojis>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "fn find_closest_emojis (multivector : & SolMultivector , emoji_multivectors : & HashMap < String , (SolMultivector , String) > ,) -> Vec < ClosestEmojiInfo > { let mut distances : Vec < (f32 , String , String) > = Vec :: new () ; for (emoji_char , (emoji_mv , category)) in emoji_multivectors { let distance = calculate_distance (multivector , emoji_mv) ; distances . push ((distance , emoji_char . clone () , category . clone ())) ; } distances . sort_by (| a , b | a . 0 . partial_cmp (& b . 0) . unwrap_or (std :: cmp :: Ordering :: Equal)) ; distances . into_iter () . take (3) . map (| (distance , emoji , category) | { ClosestEmojiInfo { emoji , category , distance , } }) . collect () }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.012838841, -0.014119775, 0.0, -0.009153224, 0.0, 0.0, 0.0, 0.026360359, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01343678, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.033026975, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0022031246, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.035437383, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "find_closest_emojisFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(multivector), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(emoji_multivectors), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(HashMap), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Tuple { paren_token: Paren, elems: [Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } }, Comma, Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }] })], gt_token: Gt } }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(ClosestEmojiInfo), arguments: PathArguments::None }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10011001";
  ex:isInFile <http://example.org/ontology/file/__src_project_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "find_closest_emojis".

<http://example.org/ontology/function/find_rust_files>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn find_rust_files (project_root : & Path) -> Vec < String > { let mut rust_files = Vec :: new () ; for entry in WalkDir :: new (project_root) . into_iter () . filter_map (| e | e . ok ()) { if entry . file_type () . is_file () { if let Some (extension) = entry . path () . extension () { if extension == \"rs\" { rust_files . push (entry . path () . to_string_lossy () . into_owned ()) ; } } } } rust_files }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.0047254073, -0.013529374, 0.0, 0.0005726736, 0.0, 0.0, 0.0, -0.0021446124, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.00088209205, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.01627555, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00560972, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044983886, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "find_rust_filesFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(project_root), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10100011";
  ex:isInFile <http://example.org/ontology/file/__src_function_analyzer_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "find_rust_files".

<http://example.org/ontology/function/generate_ontology>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn generate_ontology (analyzed_functions : Vec < crate :: project_analyzer :: AnalyzedFunction > , output_path : & Path) -> Result < () > { let mut graph = LightGraph :: new () ; let ns = namespaces :: define_namespaces () ; for func in analyzed_functions { process_function :: process_analyzed_function (& mut graph , func , & ns) ? ; } serialize :: serialize_graph_to_file (& graph , output_path , & ns . ex_iri , & ns . rdf_iri , & ns . rdfs_iri , & ns . em_iri) ? ; Ok (()) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.0046671014, -0.0016679664, 0.0, -0.012877294, 0.0, 0.0, 0.0, 0.012724684, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.016530858, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.037193976, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0063022748, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05132772, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "generate_ontologyFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(analyzed_functions), subpat: None }, colon_token: Colon, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Vec), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(crate), arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident(project_analyzer), arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident(AnalyzedFunction), arguments: PathArguments::None }] } })], gt_token: Gt } }] } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(output_path), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Tuple { paren_token: Paren, elems: [] })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10011001";
  ex:isInFile <http://example.org/ontology/file/__src_ontology_generator_mod_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "generate_ontology".

<http://example.org/ontology/function/get_sieve_address>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn get_sieve_address (multivector : & SolMultivector) -> String { let mut address = String :: with_capacity (8) ; for i in 0 .. 8 { let component = multivector . get_by_idx (1 << i) ; if component >= 0.0 { address . push ('1') ; } else { address . push ('0') ; } } address }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.011571554, -0.004597955, 0.0, -0.004231029, 0.0, 0.0, 0.0, -0.023033012, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.005471929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.016039116, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.015432459, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05239237, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "get_sieve_addressFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(multivector), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }";
  ex:hasSieveAddress "10000001";
  ex:isInFile <http://example.org/ontology/file/__src_sieve_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "get_sieve_address".

<http://example.org/ontology/function/it_works>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "# [test] fn it_works () { let file_path = \"test.txt\" ; fs :: write (file_path , \"This is a test.\") . unwrap () ; let result = process_file (file_path) ; assert ! (result . is_ok ()) ; fs :: remove_file (file_path) . unwrap () ; }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, -0.090263575, 0.048656315, 0.0, -0.054763116, 0.0, 0.0, 0.0, 0.020144863, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.08792918, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.12277863, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06576927, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06151657, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "it_works";
  ex:hasSieveAddress "01010011";
  ex:isInFile <http://example.org/ontology/file/__src_tests_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "it_works".

<http://example.org/ontology/function/load_emoji_multivectors>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn load_emoji_multivectors (ontology_path : & str) -> Result < HashMap < String , (SolMultivector , String) > > { let turtle_data = fs :: read_to_string (ontology_path) ? ; let triples : Vec < [SimpleTerm ; 3] > = parse_str (& turtle_data) . collect_triples () . map_err (| e | anyhow :: anyhow ! (\"Failed to parse Turtle: {:?}\" , e)) ? ; let mut emoji_data : HashMap < String , (String , String) > = HashMap :: new () ; let mut concept_descriptions : HashMap < String , String > = HashMap :: new () ; let em_ns = \"http://example.org/emoji#\" ; for t in triples . iter () { let subject = term_to_string (t . s ()) ; let predicate = term_to_string (t . p ()) ; let object = term_to_string (t . o ()) ; if subject . starts_with (em_ns) { let concept_id = subject . replace (em_ns , \"\") ; if predicate == format ! (\"{}emoji\" , em_ns) { let emoji_char = object . trim_matches ('\"') . to_string () ; let category = triples . iter () . find (| t2 | term_to_string (t2 . s ()) == subject && term_to_string (t2 . p ()) == format ! (\"{}category\" , em_ns)) . map (| t2 | term_to_string (t2 . o ()) . trim_matches ('\"') . to_string ()) . unwrap_or_else (| | \"Unknown\" . to_string ()) ; emoji_data . insert (emoji_char , (concept_id . clone () , category)) ; } else if predicate == format ! (\"{}description\" , em_ns) { concept_descriptions . insert (concept_id , object . trim_matches ('\"') . to_string ()) ; } } } let mut emoji_multivectors : HashMap < String , (SolMultivector , String) > = HashMap :: new () ; let config = BertConfig :: default () ; let encoder = BertCliffordEncoder :: new (config) ; for (emoji_char , (concept_id , category)) in emoji_data { let description = concept_descriptions . get (& concept_id) . cloned () . unwrap_or (concept_id . clone ()) ; let bert_embedding = embedding :: embed_text (& description) ? ; let multivector = encoder . encode_embedding (& bert_embedding) ? ; emoji_multivectors . insert (emoji_char , (multivector , category)) ; } Ok (emoji_multivectors) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.026047604, 0.001776018, 0.0, -0.012083835, 0.0, 0.0, 0.0, 0.03040901, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.023500374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.027902707, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.002274598, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.052805897, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "load_emoji_multivectorsFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(ontology_path), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(str), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(HashMap), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Tuple { paren_token: Paren, elems: [Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } }, Comma, Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }] })], gt_token: Gt } }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "11011001";
  ex:isInFile <http://example.org/ontology/file/__src_load_emoji_multivectors_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "load_emoji_multivectors".

<http://example.org/ontology/function/main>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "fn main () { let args : Vec < String > = env :: args () . collect () ; if args . len () != 2 { eprintln ! (\"Usage: cargo run -- <project_root_path>\") ; return ; } let project_root = Path :: new (& args [1]) ; let ontology_path = Path :: new (\"../ontologies/zos/v1.ttl\") ; let output_ontology_path = Path :: new (\"project_ontology.ttl\") ; println ! (\"Analyzing project: {}\" , project_root . display ()) ; let pb = ProgressBar :: new_spinner () ; pb . set_style (ProgressStyle :: default_spinner () . template (\"{spinner:.green} {msg}\") . unwrap ()) ; pb . set_message (\"Analyzing project files...\") ; pb . enable_steady_tick (std :: time :: Duration :: from_millis (100)) ; match analyze_project (project_root , ontology_path) { Ok (analyzed_functions) => { pb . finish_with_message (\"Project analysis complete.\") ; println ! (\"\\n--- Analysis Results ---\") ; if analyzed_functions . is_empty () { println ! (\"No functions found or analyzed in the project.\") ; } else { for func in & analyzed_functions { println ! (\"\\nFile: {}\" , func . file_path) ; println ! (\"  Function: {}\" , func . function_name) ; println ! (\"  Code Snippet (first 100 chars): '{:.100}'\\n\" , func . code_snippet) ; println ! (\"  Semantic Summary (first 100 chars): '{:.100}'\\n\" , func . semantic_summary) ; println ! (\"  Multivector: {}\" , func . multivector_str) ; println ! (\"  Sieve Address: {}\" , func . sieve_address) ; println ! (\"  Closest Emojis:\") ; for emoji_info in & func . closest_emojis { println ! (\"    - {} ({}) with distance: {}\" , emoji_info . emoji , emoji_info . category , emoji_info . distance) ; } } match generate_ontology (analyzed_functions , output_ontology_path) { Ok (_) => println ! (\"\\nSuccessfully generated ontology to {}.\" , output_ontology_path . display ()) , Err (e) => eprintln ! (\"Error generating ontology.\") , } } } Err (e) => { pb . finish_with_message (\"Project analysis failed.\") ; eprintln ! (\"Error analyzing project: {}\" , e) ; } } }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, -0.12565847, 0.03225677, 0.0, -0.07536044, 0.0, 0.0, 0.0, 0.16418226, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.09738033, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.03128668, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.049015902, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044808216, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "main";
  ex:hasSieveAddress "01010011";
  ex:isInFile <http://example.org/ontology/file/__src_main_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "main".

<http://example.org/ontology/function/process_analyzed_function>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn process_analyzed_function < G > (graph : & mut G , func : AnalyzedFunction , ns : & Namespaces ,) -> anyhow :: Result < () > where G : MutableGraph , < G as MutableGraph > :: MutationError : Send + Sync + 'static , { let func_iri = SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}function/{}\" , ns . ex_iri . as_str () , func . function_name) . into ())) ; let file_iri = SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}file/{}\" , ns . ex_iri . as_str () , func . file_path . replace (\".\" , \"_\") . replace (\"/\" , \"_\") . replace (\"-\" , \"_\")) . into ())) ; graph . insert (& func_iri , & ns . rdf . iri () . unwrap () , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}Function\" , ns . ex_iri . as_str ()) . into ()))) ? ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}label\" , ns . rdfs_iri . as_str ()) . into ())) , func . function_name . as_str ()) ? ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}hasCodeSnippet\" , ns . ex_iri . as_str ()) . into ())) , func . code_snippet . as_str ()) ? ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}hasSemanticSummary\" , ns . ex_iri . as_str ()) . into ())) , func . semantic_summary . as_str ()) ? ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}hasMultivectorEmbedding\" , ns . ex_iri . as_str ()) . into ())) , func . multivector_str . as_str ()) ? ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}hasSieveAddress\" , ns . ex_iri . as_str ()) . into ())) , func . sieve_address . as_str ()) ? ; for (i , emoji_info) in func . closest_emojis . iter () . enumerate () { let emoji_iri = SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}closestEmoji/{}\" , ns . ex_iri . as_str () , i) . into ())) ; graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}hasClosestEmojiInfo\" , ns . ex_iri . as_str ()) . into ())) , & emoji_iri) ? ; graph . insert (& emoji_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}emojiChar\" , ns . ex_iri . as_str ()) . into ())) , emoji_info . emoji . as_str ()) ? ; graph . insert (& emoji_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}emojiCategory\" , ns . ex_iri . as_str ()) . into ())) , emoji_info . category . as_str ()) ? ; graph . insert (& emoji_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}emojiDistance\" , ns . ex_iri . as_str ()) . into ())) , & (emoji_info . distance as f64) . into_term :: < SimpleTerm > ()) ? ; } graph . insert (& func_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}isInFile\" , ns . ex_iri . as_str ()) . into ())) , & file_iri) ? ; graph . insert (& file_iri , & ns . rdf . iri () . unwrap () , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}CodeFile\" , ns . ex_iri . as_str ()) . into ()))) ? ; graph . insert (& file_iri , & SimpleTerm :: Iri (IriRef :: new_unchecked (format ! (\"{}label\" , ns . rdfs_iri . as_str ()) . into ())) , func . file_path . as_str ()) ? ; Ok (()) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.008782949, -0.004813557, 0.0, -0.022073712, 0.0, 0.0, 0.0, -0.009760023, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.024176234, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.039983734, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.018057786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04324036, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "process_analyzed_functionFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(graph), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: Some(Mut), elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(G), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(func), subpat: None }, colon_token: Colon, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(AnalyzedFunction), arguments: PathArguments::None }] } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(ns), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Namespaces), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(anyhow), arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Tuple { paren_token: Paren, elems: [] })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10001011";
  ex:isInFile <http://example.org/ontology/file/__src_ontology_generator_process_function_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "process_analyzed_function".

<http://example.org/ontology/function/process_code>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn process_code (code_content : & str) -> Result < SolMultivector > { let bert_embedding = embedding :: embed_text (code_content) ? ; let config = BertConfig :: default () ; let encoder = BertCliffordEncoder :: new (config) ; let multivector = encoder . encode_embedding (& bert_embedding) ? ; Ok (multivector) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.020558521, -0.01814922, 0.0, -0.018116917, 0.0, 0.0, 0.0, 0.00086287083, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.015731223, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.02186402, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.010442836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.034021076, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "process_codeFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(code_content), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(str), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SolMultivector), arguments: PathArguments::None }] } })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10011011";
  ex:isInFile <http://example.org/ontology/file/__src_process_file_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "process_code".

<http://example.org/ontology/function/serialize_graph_to_file>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "pub fn serialize_graph_to_file < G > (graph : & G , output_path : & Path , ex_iri : & IriRef < String > , rdf_iri : & IriRef < String > , rdfs_iri : & IriRef < String > , em_iri : & IriRef < String > ,) -> anyhow :: Result < () > where G : Graph , < G as Graph > :: Error : Send + Sync + 'static , { let mut prefix_map = TurtleConfig :: default_prefix_map () ; prefix_map . push ((Prefix :: new_unchecked (\"ex\" . into ()) , Iri :: new_unchecked (ex_iri . as_str () . into ()))) ; prefix_map . push ((Prefix :: new_unchecked (\"rdf\" . into ()) , Iri :: new_unchecked (rdf_iri . as_str () . into ()))) ; prefix_map . push ((Prefix :: new_unchecked (\"rdfs\" . into ()) , Iri :: new_unchecked (rdfs_iri . as_str () . into ()))) ; prefix_map . push ((Prefix :: new_unchecked (\"em\" . into ()) , Iri :: new_unchecked (em_iri . as_str () . into ()))) ; let config = TurtleConfig :: new () . with_pretty (true) . with_own_prefix_map (prefix_map) ; let mut writer = TurtleSerializer :: new_with_config (BufWriter :: new (File :: create (output_path) ?) , config) ; writer . serialize_graph (& graph) ? ; Ok (()) }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.014888525, -0.02798346, 0.0, -0.019532336, 0.0, 0.0, 0.0, 0.022766974, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0043934328, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.01927027, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.007304233, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.054865584, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "serialize_graph_to_fileFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(graph), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(G), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(output_path), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(Path), arguments: PathArguments::None }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(ex_iri), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(IriRef), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } })], gt_token: Gt } }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(rdf_iri), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(IriRef), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } })], gt_token: Gt } }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(rdfs_iri), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(IriRef), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } })], gt_token: Gt } }] } } } })FnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(em_iri), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(IriRef), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } })], gt_token: Gt } }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(anyhow), arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident(Result), arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Tuple { paren_token: Paren, elems: [] })], gt_token: Gt } }] } }";
  ex:hasSieveAddress "10011011";
  ex:isInFile <http://example.org/ontology/file/__src_ontology_generator_serialize_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "serialize_graph_to_file".

<http://example.org/ontology/function/term_to_string>
  ex:hasClosestEmojiInfo <http://example.org/ontology/closestEmoji/0>,
    <http://example.org/ontology/closestEmoji/1>,
    <http://example.org/ontology/closestEmoji/2>;
  ex:hasCodeSnippet "fn term_to_string (term : & SimpleTerm) -> String { match term { SimpleTerm :: Iri (iri) => iri . to_string () , SimpleTerm :: LiteralDatatype (value , _) => value . to_string () , SimpleTerm :: LiteralLanguage (value , _) => value . to_string () , _ => \"\" . to_string () , } }";
  ex:hasMultivectorEmbedding "MultivectorBase { t: PhantomData<f32>, a: PhantomData<prepare_sources::clifford::SolCl>, coeffs: ArrayStorage { dim: 8, array: [0.0, 0.02124683, 0.012224076, 0.0, 0.025965724, 0.0, 0.0, 0.0, 0.0065616723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004153562, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.026859455, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.009405305, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04099559, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], shape=[256], strides=[1], layout=CFcf (0xf), const ndim=1 } }";
  ex:hasSemanticSummary "term_to_stringFnArg::Typed(PatType { attrs: [], pat: Pat::Ident { attrs: [], by_ref: None, mutability: None, ident: Ident(term), subpat: None }, colon_token: Colon, ty: Type::Reference { and_token: And, lifetime: None, mutability: None, elem: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(SimpleTerm), arguments: PathArguments::None }] } } } })Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(String), arguments: PathArguments::None }] } }";
  ex:hasSieveAddress "11111011";
  ex:isInFile <http://example.org/ontology/file/__src_load_emoji_multivectors_rs>;
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ex:Function;
  rdfs:label "term_to_string".

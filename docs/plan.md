#### Client side interpretation.#### Server side storageThe first memes are just free text stored as instructions in the blockchaineach one can be seen as a rust program that when executed produces some text or json or urlWe can parameterize those. the programs can be updated by creating new versions of thembecause we are on a sidechain we can rewrite or garbage collect them.##### Import Gitwe can use git submodules or git urls like package managers do,###### Import Data via gitwe can import telegram, discord, twitter, github, ai chat logs, files into the system.each sidechain becomes its own meme database with all the transactions around a meme coin ecosystem.see the time repo for example.######## A tweet becomes a program or meme, an anchor is the code.#### Forking all repos into our chain#### Copying all data into our archives#### Running all code on our chain#### Proving all code to be valid.#### Showing execution of all paths of the codeusing dfa and parsers for the emoji language. each version of the meme state is a new version of the language and library.we hope to construct that each path in the system is a unique word and a program at the same time that has a meaning in emojis.#### Mathematical modeling of the structures (groups, hott, etc)#### Using of AI outside the system, storing results on the chain.##### AI via client side inferences###### looking at Invoke AI for example###### looking at Kobold AI for example###### calling typescript from rust wasm dioxus (calling eliza?)#### Tracing the AI inference into the model.#### Convert this source to jsonCreateing json  using https://github.com/meta-introspector/syn-serde-rust.git ```    cd .\syn-serde-rust\    cargo build    cd .\examples\rust2emoji\    cargo build    cargo run ..\..\..\solfunmeme-dioxus\```#### Reading in source of code via reflection. splitting into chunks. saving in the blockchain.#### interpreting the functions as json or emojis#### linking functions together creating systems as groups of contracts.#### embedding contrats as vectors